/**
 * \file    level_1.c
 * \version 0.0.1
 * \date    08/03/2024
 * \author  Erick Calegaro
 */

/*****************************************************************************
 * Includes
 *****************************************************************************/

#include "main.h"
#include "screen.h"
#include "control.h"

/*****************************************************************************
 * Preprocessor Macros and Defines
 *****************************************************************************/


/*****************************************************************************
 * Typedefs and Variable Definitions
 *****************************************************************************/

static e_TileType giArrayMapLevel1[NUM_ROWS][NUM_COLUMNS] = {
    { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    {15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15},
    {12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
    {12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
    {12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, 0, 2,12,12,12,12,12,12,12},
    {21,22,22,22,22,23,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,21, 5, 5,23,12,12,12,12,12,12},
    {12,12,12,12,12,12,12,12,21,22,22,22,22,22,23,12,12,21,23,12,12,12,12,12,21,22,22,23,12,12,12,12,12,12,12,12, 0, 1, 1, 1},
    {12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,21,22,23,12,12,12,12,12,12,12,12,12,12,12, 0,20, 8, 8, 8},
    {21,22,23,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,24,12,12,12,12,12,12,12,12, 0, 1, 1, 1, 1, 1,20, 8, 8, 8, 8},
    {12,12,12,21,23,12,12,12,12,12,12,12,12,12,12,12,12,21,22,23,12,12,12,12,12,12,12,12, 0,20, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    {12,12,12,12,12,12,12,12, 0, 1, 1, 1,22,22,23,12,12,12,12,12,12,12,12,12,12,12,12, 0,20, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    {12,12,12,12,12,12,12, 0,20, 8, 8,16,12,12,12,12,12,12,12,12,12,12,12,12,12,12, 0,20, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    {12,12,12,12,12,12, 0,20, 8, 8,16,12,12,12,12,12,12,12,12,12,12,12,12,12,12, 0,20, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 1, 1, 1, 1, 1, 1,20, 8, 8,16,12,12,12,26, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,20, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 8, 8, 8, 8, 8, 8, 8, 8,16,12,12,12,26, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    { 8, 8, 8, 8, 8, 8, 8,16,12,12,12,26, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
};

/*****************************************************************************
 * Private Function Prototypes
 *****************************************************************************/

/**
 * \brief Cria e inicializa o mapa que será utilizado na fase 1.
 * \param void
 * \returns RET_OK - Caso sucesso; 
 *          RET_MAP_ERROR - Caso falhe na criação do mapa;  
 */
static e_Ret level_1_Init(void);

/*****************************************************************************
 * Private Function Definitions
 *****************************************************************************/

static e_Ret level_1_Init(void)
{
    e_Ret eRet = RET_OK;
    eRet = map_Create(STATE_LEVEL_1);
    if (eRet){
        printf("Nao foi possivel inicializar as texturas!\n");
        return RET_MAP_ERROR;
    }

    t_Position tPosition;
    tPosition.hEntityID = ghPlayerHandle;
    tPosition.iPosX     = 1;
    tPosition.iPosY     = (15 * TILE_SCALE); //Posição do Player para a fase
    eRet = entity_UpdatePosition(&tPosition);
    if (eRet){
        printf("Nao foi possivel definir posicoes iniciais para entidade!\n");
        return RET_POS_ERROR;
    }

    map_Load(giArrayMapLevel1);
    collision_Load(giArrayMapLevel1);

    return RET_OK;
}


/*****************************************************************************
 * Public Function Definitions
 *****************************************************************************/

e_Ret level_1_Loop(e_State * peNextState)
{
    peNextState = peNextState; //Unref parameter
    
    e_Ret   eRet         = RET_OK;
    Uint32  uiFrameStart = 0;
    int     iFrameTime   = 0;

    eRet = level_1_Init();
    if (eRet){
        printf("Nao foi possivel inicializar o mapa!\n");
        return RET_INIT_ERROR;
    }

    do{
        uiFrameStart = SDL_GetTicks();

        control_HandleEvents();
        
        eRet = keyboard_HandleEvents();
        if (eRet){
            printf("Nao foi possivel movimentar o jogador!\n");
            break;
        }

        screen_Update();
        eRet = screen_Render();
        if (eRet){
            printf("Nao foi possivel renderizar a tela!\n");
            break;
        }
        
        iFrameTime = SDL_GetTicks() - uiFrameStart;

        if (FRAME_DELAY > iFrameTime){ //Trava de FPS
            SDL_Delay(FRAME_DELAY - iFrameTime);
        }
        
    } while (control_GetRunning());

    return RET_OK;
}